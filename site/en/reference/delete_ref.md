---
id: delete_ref.md
related_key: Delete
summary: Milvus supports deleting entities, and here is how.
---

# Data Deletion

In Milvus, you can delete an entity in a given collection with its primary key so that the deleted entity will no longer be listed in the result of a search or a query.

This topic assumes that you have a primary understanding of data insertion process in Milvus. If not, we recommend reading [Data insertion](data_processing.md#Data-insertion) and [Glossary - Segment](glossary.md#Segment).

## Implementation

Through primary key hashing, proxy routes the data insertion and deletion requests to different shards. Data node and query node consume these requests separately and provide search and query services together.

### Data node

When processing data insertion requests, data node temporarily buffers the newly inserted data in a growing segment in memory, and seals and flushes the segment to the object storage when either the data row count or buffering time of the segment reaches the threshold. While flushing the sealed segment, data node generates a bloom filter based on the primary key filed and stores it in the statistics binary log (stats binlog).

<div class="alert quote">

A bloom filter is a probabilistic data structure that consists of a long binary vector and a series of random mapping functions. It can be used to test whether an element is a member of a set, but may return false positive matches.

</div>

Data node processes data insertion and deletion requests consistently through the sharding mechanism, meaning that the shard from which an entity is flushed will consequentially process the deletion request of the entity based on the corresponding bloom filter generated by this very shard of the data node. 

When receiving deletion requests from DML-Channel, data node buffers all bloom filters in the corresponding shard (to avoid repetitive loading), matches them with the provided primary keys, and therefore pinpoints the segments that include the entities to delete. Having found the corresponding segments, data node buffers the segments in memory to generate the delta binlogs to record the deletion operations, and then flushes those binlogs together with the segments to the object storage.

Because not all query nodes subscribe to DML-Channel, data nodes filters all deletion requests in DML-Channel, and forwards them to Delta-Channel to notify query nodes the deletion operations.

### Query node

When loading a collection from object storage, query node first obtains each shard's checkpoint, which marks the DML operations since the last flush operation, and loads the corresponding sealed segments, delta binlogs, and bloom filters from object storage according to the checkpoints, and then subscribes to DML-Channel, Delta-Channel, and Query-Channel.

If more insertion requests come after the collection is loaded, query node first pinpoints the growing segments corresponded to the requests, and updates the bloom filters for query purpose only in memory. Those query-dedicated bloom filters will not be flushed to object storage after the query is finished.

For query node which has subscribed to and received the deletion requests from the DML-Channel, it first filters the requests in the growing segments, locates the entities by matching the provided primary keys with the bloom filters of the growing segments, and then records the deletion operations in the corresponding segments.

As for sealed segments, query node collects all deletion requests in sealed segments from Delta-Channel, locates the entities by matching the provided primary keys with the bloom filters of the sealed segments, and then records the deletion operations in the corresponding segments.

When receiving query or search requests, query node first generates a bitset based the deletion records to omit the deleted entities, and then retrieves entities from all segments, regardless of their status. 